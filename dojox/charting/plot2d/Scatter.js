dojo.provide("dojox.charting.plot2d.Scatter");

dojo.require("dojox.charting.plot2d.common");
dojo.require("dojox.charting.plot2d.Base");

dojo.require("dojox.lang.utils");
dojo.require("dojox.lang.functional");
dojo.require("dojox.lang.functional.reversed");

dojo.require("dojox.gfx.gradutils");


(function(){
	var df = dojox.lang.functional, du = dojox.lang.utils,
		dc = dojox.charting.plot2d.common,
		purgeGroup = df.lambda("item.purgeGroup()");

	dojo.declare("dojox.charting.plot2d.Scatter", dojox.charting.plot2d.Base, {
		defaultParams: {
			hAxis: "x",		// use a horizontal axis named "x"
			vAxis: "y",		// use a vertical axis named "y"
			shadows: 0		// draw shadows
		},
		optionalParams: {},	// no optional parameters
		
		constructor: function(chart, kwArgs){
			this.opt = dojo.clone(this.defaultParams);
			du.updateWithObject(this.opt, kwArgs);
			this.series = [];
			this.hAxis = this.opt.hAxis;
			this.vAxis = this.opt.vAxis;
		},
		
		calculateAxes: function(dim){
			this._calc(dim, dc.collectSimpleStats(this.series));
			return this;
		},

		render: function(dim, offsets){
			this.dirty = this.isDirty();
			if(this.dirty){
				dojo.forEach(this.series, purgeGroup);
				this.cleanGroup();
				var s = this.group;
				df.forEachRev(this.series, function(item){ item.cleanGroup(s); });
			}
			var t = this.chart.theme, useColors = t.useColors(),
				sTheme, fill, stroke, outline, color, marker, events = this.events();
			this.resetEvents();
			for(var i = this.series.length - 1; i >= 0; --i){
				var run = this.series[i];
				if(!this.dirty && !run.dirty){ continue; }
				run.cleanGroup();
				if(!run.data.length){
					run.dirty = false;
					continue;
				}

				var s = run.group, lpoly, 
					ht = this._hScaler.scaler.getTransformerFromModel(this._hScaler),
					vt = this._vScaler.scaler.getTransformerFromModel(this._vScaler);
				if(typeof run.data[0] == "number"){
					lpoly = dojo.map(run.data, function(v, i){
						return {
							x: ht(i + 1) + offsets.l,
							y: dim.height - offsets.b - vt(v)
						};
					}, this);
				}else{
					lpoly = dojo.map(run.data, function(v, i){
						return {
							x: ht(v.x) + offsets.l,
							y: dim.height - offsets.b - vt(v.y)
						};
					}, this);
				}

				var lpath = this.opt.tension ? dc.curve(lpoly, this.opt.tension) : "";

				if(useColors){
					if(!run.fill || !run.stroke){
						// need autogenerated color
						color = run.dyn.color = new dojo.Color(t.next("color"));
					}
				}else{
					sTheme = t.next("series");
				}
				run.dyn.stroke = stroke = run.stroke ? dc.makeStroke(run.stroke) : (useColors ? dc.augmentStroke(t.series.stroke, color) : sTheme.stroke);
				fill = run.fill ? run.fill : (useColors ? dc.augmentFill(t.series.fill, color) : sTheme.fill);
				run.dyn.fill = fill = this._plotFill(fill, dim, offsets);

				if(run.outline || t.series.outline){
					outline = run.dyn.outline = dc.makeStroke(run.outline ? run.outline : t.series.outline);
					outline.width = 2 * outline.width + stroke.width;
				}
				
				// need a marker
				marker = run.dyn.marker = run.marker ? run.marker : t.next("marker");

				var frontMarkers = null, outlineMarkers = null, shadowMarkers = null;
				if(this.opt.shadows && stroke){
					var sh = this.opt.shadows, shadowColor = new dojo.Color([0, 0, 0, 0.3]),
						spoly = dojo.map(lpoly, function(c){
							return {x: c.x + sh.dx, y: c.y + sh.dy};
						}),
						shadowStroke = dojo.clone(outline ? outline : stroke);
					shadowStroke.color = shadowColor;
					shadowStroke.width += sh.dw ? sh.dw : 0;
					shadowMarkers = dojo.map(spoly, function(c){
						return s.createPath("M" + c.x + " " + c.y + " " + marker).
							setStroke(shadowStroke).setFill(shadowColor);
					}, this);
				}

				frontMarkers = new Array(lpoly.length);
				outlineMarkers = new Array(lpoly.length);
				dojo.forEach(lpoly, function(c, i){
					var path = "M" + c.x + " " + c.y + " " + marker;
					if(outline){
						outlineMarkers[i] = s.createPath(path).setStroke(outline);
					}
					if(fill.type === "linear"){
						stroke.color = dojox.gfx.gradutils.getColor(fill, {x: c.x, y: c.y});
						frontMarkers[i] = s.createPath(path).setStroke(stroke).setFill(stroke.color);
					}else{
						frontMarkers[i] = s.createPath(path).setStroke(stroke).setFill(stroke.color);
					}
				}, this);
				if(events){
					dojo.forEach(frontMarkers, function(s, i){
						var o = {
							element: "marker",
							index:   i,
							run:     run,
							plot:    this,
							hAxis:   this.hAxis || null,
							vAxis:   this.vAxis || null,
							shape:   s,
							outline: outlineMarkers[i] || null,
							shadow:  shadowMarkers && shadowMarkers[i] || null,
							cx:      lpoly[i].x,
							cy:      lpoly[i].y
						};
						if(typeof run.data[0] == "number"){
							o.x = i + 1;
							o.y = run.data[i];
						}else{
							o.x = run.data[i].x;
							o.y = run.data[i].y;
						}
						this._connectEvents(s, o);
					}, this);
				}
				run.dirty = false;
			}
			this.dirty = false;
			return this;
		}
	});
})();
